目的：

我们将在这篇教程中解决以下问题：

* 我们将如何遍历一张图片的每一个像素？
* OpenCV矩阵值具体是如何存储的？
* 如何衡量我们的算法性能？
* 什么是查找表？如何使用查找表？

测试用例

我们先来分析简单的颜色消除算法。矩阵中的元素数据是按照C和C++的无符号字符类型存储，每一个像素的通道有256种不同的值。对一个有三个通道的图像来说，我们可以生成许多种颜色（大概有1600万颜色）。对这么多的颜色进行处理会严重降低算法的性能。然而，有时候如果我们能对这个图像的部分数据进行舍弃的话，我们依旧可以达到我们想要的效果。

在这个例子当中，我们会使用色域消减的方法来提高性能。也就是说，我们将色域分解，然后设定范围，让当前色域的值设置成一个新值，从而减少颜色的处理规模。这个例子里，0-9的值，我们会赋值为0；10-19的值，我们就赋值为10。

当你区分uchar（unsigned char，其值在0-255之间）和int类型的值时，程序会自动转换为char类型。这些值同样会变成char类型。因此，值域范围会逐步缩小。使用这个功能之后，uchar的值的改变是由以下公式决定的：

![](http://latex.codecogs.com/gif.latex?I_{new}=(\frac{I_{old}}{10})*10)

一个简单的色域消除算法只是将图形矩阵的每一个像素传入这个公式中在进行处理。我们如果只是简单地执行乘除运算是没有多少意义的。这些运算对于机器而言十分耗性能。如果我们尽可能避免这种方法，而采用一些简单的运算方式，比如转化成加减法、或者转化成更为简单的任务。另外，我们要注意到，输入值是有一个非常明显的上界。在这个例子中，uchar最多有256个值。

因此，对于一些体积更大的图像而言，最好的方式是将所有可能的值在处理之前先算出来，通过查找表的时候只做任务分配。查找表是一个简单的数组（有一维和多维之分），表的内容是将输入值变量和最终输出值一一对应。他的优点就在于我们根据这张表格来查找计算结果，而不是每次都需要计算数据。

我们的这个测试程序（就是我们目前展示的这个）将实现以下功能：在控制台上用命令读取一张图片，图片是命令行的一个参数（可能是多种颜色的，也有可能是灰阶——同样也是命令行参数的形式）并且通过命令行参数的形式传递一个整数值来指明降低的程度。在OpenCV库中，目前有三种方式来处理图片中的各个像素点。为了让这三种扫描图形方法的效果变得更加直观有趣，我们会将每个方法的运行时间打印出来。

你可以在这儿下载本文所涉及的全部源代码或者在OpenCV的源代码samples目录中C++代码部分找到本文代码。它的基本用法是：

```
how_to_scan_images imageName.jpg intValueToReduce [G]
```

最后一个命令是可选的。如果指明了这个选项，图像是以灰阶方式加载的，否则就按照BGR色域方式加载图像。我们要做的第一件事便是计算查询表。

```
int divideWith = 0; // convert our input string to number - C++ style
stringstream s;
s << argv[2];
s >> divideWith;
if (!s || !divideWith)
{
    cout << "Invalid number entered for dividing. " << endl;
    return -1;
}
uchar table[256];
for (int i = 0; i < 256; ++i)
   table[i] = (uchar)(divideWith * (i/divideWith));
```


这里，第一步，我们先使用了C++中的stringsream类来将第三个命令行参数转化为整型。接着我们再简单看看上面提到的公式，这个公式用来生成查询表。我们并没有使用到OpenCV的功能。

另外一个问题是，我们应该如何确定程序最终运行所需要的时间？对于这个问题，OpenCV提供了cv::getTickCount()和cv::getTickfrequency()两个简单的函数来处理。第一个返回在特定情况下你的CPU时钟数（比如，你开机以后）。第二个函数返回你的CPU每秒滴答的次数。所以，在这两者之间计算程序运行的时长只需要通过以下简单的方法即可实现：

```
double t = (double)getTickCount();
// do something ...
t = ((double)getTickCount() - t)/getTickFrequency();
cout << "Times passed in seconds: " << t << endl;
```

图形矩阵在内存中所占用的内存大小

正如之前的《Mat——基本图像容器》教程所提及的，矩阵的大小决定于使用的色域。更加精确的色域取决于使用的通道数。在一张灰阶的图形中，我们会得到下面的矩阵：

![](https://docs.opencv.org/4.1.0/tutorial_how_matrix_stored_1.png)

对于多通道图像而言，通道中的小通道才是图像的通道数。例如在BGR图像系统中：

![](https://docs.opencv.org/4.1.0/tutorial_how_matrix_stored_2.png)

需要注意的是，我们所用的图像系统和我们认知的图像系统是不一样的：BGR，而不是RGB。因为在许多情况下，内存是可以以列排序的方式容纳下许多密集的数据，这样数据一个接一个紧密相连，从形成简单的长列。因为在许多时候，所有的数据都放在同一个地方，紧紧排列会帮助加快扫描进度。所以，我们便可以使用cv::Mat::isContinous()函数来判断矩阵是否满足之前说的条件。我们会在下一个章节介绍使用的方法。

有效的方法

当谈到有关性能问题的时候，C语言永远是第一名，传统的C指针风格访问形式永远是最优的。因此，我们在处理OpenCV数据的时候，最有效的方法便是下面的代码：

```
Mat& ScanImageAndReduceC(Mat& I, const uchar* const table)
{
    // accept only char type matrices
    CV_Assert(I.depth() == CV_8U);
    int channels = I.channels();
    int nRows = I.rows;
    int nCols = I.cols * channels;
    if (I.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }
    int i,j;
    uchar* p;
    for( i = 0; i < nRows; ++i)
    {
        p = I.ptr<uchar>(i);
        for ( j = 0; j < nCols; ++j)
        {
            p[j] = table[p[j]];
        }
    }
    return I;
}
```

在这里，我们直接简单的使用了一个指针，这个指针从每一行的开始指向这一行的结束。在这个比较特别的测试集中矩阵是存储在一个连续的地方，所以我们只需要让指针指向数据集一次即可，然后从头读到尾。我们需要考虑到彩色图片：我们有三个通道，也就意味着我们需要在每一行的处理时间要是原来的三倍多。

当然，我们还可以用其他方法实现。Mat数据中的data部分返回了指向第一行第一列的指针。如果指针为空，则说明在Mat并没有合适的数据。检查数据是否为空的最最简单方法便是检查你的图片是否加载成功。在本例子中，数据的存储是连续的，因此我们用一个指针遍历所有数据。在一张灰阶图片里，程序应该是这样写的：

```
uchar* p = I.data;
for( unsigned int i =0; i < ncol*nrows; ++i)
    *p++ = table[*p];
```

你可以在你的程序中得到同样的结果。然而，接下来的代码会变的相当复杂。如果你使用了更多的高级特性，代码会变得更加难懂。另外，实际上，你只能得到同样的性能（因为实际情况下，大多数近期的编译器都会对你的代码进行微小的优化，这让你的代码运行起来相差无几。）

迭代器方法（安全）

在这最有效率的方法里，你要确保你传递了正确数量的uchar大小并能正确跳过在内存中行与行之间的空隙。迭代器方法由于减轻了程序员的任务，从而被认为是一种非常安全的方法。你所需要做的便是在一开始的时候请求图形矩阵的头部和尾部，然后反复执行迭代器的递归功能，直到达到矩阵的末端。获取值只需要通过迭代器的\*运算符即可实现（\*加在迭代器的前面）。

```
Mat& ScanImageAndReduceIterator(Mat& I, const uchar* const table)
{
    // accept only char type matrices
    CV_Assert(I.depth() == CV_8U);
    const int channels = I.channels();
    switch(channels)
    {
    case 1:
        {
            MatIterator_<uchar> it, end;
            for( it = I.begin<uchar>(), end = I.end<uchar>(); it != end; ++it)
                *it = table[*it];
            break;
        }
    case 3:
        {
            MatIterator_<Vec3b> it, end;
            for( it = I.begin<Vec3b>(), end = I.end<Vec3b>(); it != end; ++it)
            {
                (*it)[0] = table[(*it)[0]];
                (*it)[1] = table[(*it)[1]];
                (*it)[2] = table[(*it)[2]];
            }
        }
    }
    return I;
}
```

在这个彩色图片中，我们在每一行中都有三个uchar子列。这是通过OpenCV的Vec3b方法进行了预先处理，由此我们可以把它看做是一个uchar类型的short vector对象。通过[]运算符，我们可以访问第n个子列。我们需要着重强调的是，OpenCV的迭代器是按列访问的，会自动跳到下一行去。因此，在这张图片中，如果你只是用了一个uchar迭代器，你将只能访问蓝色通道的值。

通过引用返回的方式在运行时进行地址修改

最后一个方法并不推荐使用扫描的方法进行遍历。这个方法被用于获取或者修改图片的部分随机元素。它的基本方式是，修改你想访问元素的行数和列数。在之前的扫描方法中，你可以发现这个过程中最重要的是知道我们在查看图片时需要什么类型的元素。在自动查找的时候手动指明要查看的类型时，这几种方法之间没有什么区别。通过下面的代码，你能知道在灰阶图像中如何实现之前的扫描方法（cv::Mat::at()函数方法）：

```
Mat& ScanImageAndReduceRandomAccess(Mat& I, const uchar* const table)
{
    // accept only char type matrices
    CV_Assert(I.depth() == CV_8U);
    const int channels = I.channels();
    switch(channels)
    {
    case 1:
        {
            for( int i = 0; i < I.rows; ++i)
                for( int j = 0; j < I.cols; ++j )
                    I.at<uchar>(i,j) = table[I.at<uchar>(i,j)];
            break;
        }
    case 3:
        {
         Mat_<Vec3b> _I = I;
         for( int i = 0; i < I.rows; ++i)
            for( int j = 0; j < I.cols; ++j )
               {
                   _I(i,j)[0] = table[_I(i,j)[0]];
                   _I(i,j)[1] = table[_I(i,j)[1]];
                   _I(i,j)[2] = table[_I(i,j)[2]];
            }
         I = _I;
         break;
        }
    }
    return I;
}
```

函数会分析你的输入类型和坐标，并对请求的元素在运行的时候进行地址计算。函数会返回一个应用指针。使用get的时候获得的是常量，而使用set的时候使用的是非常量。这是仅在调试模式中存在的安全步骤，这一步会检查你输入的坐标是有效的并且真实存在的。如果检查失败，程序便会从标准错误输出流中输出错误信息。相比于发布模式，这个方法有一点不同，在每一个图形元素中，你都会得到一个新的行指针，我们会通过C操作符[]来获得列指针。

如果你需要通过这种方式对一个图像的查找表进行修改，这会变得问题多多并且耗费大量的时间，在每一次访问类型和关键字的时候尤为明显。为了解决这个问题，OpenCV设计了cv::Mat_数据类型。这个数据类型跟Mat一致，只不过在一开始使用的时候需要在查看数据矩阵的时候指明数据类型。并且返回的时候使用()操作符来快速访问所需元素。为了更方便用户使用，Mat和Mat_类型之间可以实现轻松互转。在上文的函数中，你就能看到对彩色图像处理的例子。不仅如此，还有一点非常重要，同样的操作（在同样的运行时速度情况下）可以通过cv::Mat::at函数实现。这为一些“偷懒”的程序员提供了一些编程技巧。

核心函数

这里我们提供额外的教程，告诉大家如何实现对图像的查找表进行修改。在图像处理中，你非常希望能够修改给定图像的所有值。OpenCV提供了一个函数来修改图像值，也不需要读写图像的扫描方式。我们使用的是核心模块中的cv::LUT()函数。第一步，我们先要构建查找表的Mat类型。

```
Mat lookUpTable(1, 256, CV_8U);
uchar* p = lookUpTable.ptr();
for( int i = 0; i < 256; ++i)
    p[i] = table[i];
```

最后调用函数(I是输入图像，J是输出图像）

```
LUT(I, lookUpTable, J);
```

性能比较

为了有更好的结果，你需要请自编译程序，并在自己的机器上运行。为了确保有明显的差距，我用了一张非常大的图片（2560X1600）。下表就是处理这张彩色图片需要的时间。为了有更精确的结果，我运行了上百次，然后取了平均值。

方法 | 时间 | 
-|-|
Efficient Way| 79.4717 milliseconds |
Iterator | 83.7201 milliseconds |
On-The-Fly RA | 93.7878 milliseconds |
LUT function | 32.5759 milliseconds |

我们可以通过这张表格得出非常多的结论。我们需要尽可能地使用OpenCv自带的函数（而不是自己去再写一个）。在这其中，最快的函数是LUT函数。这是因为通过英特尔的线程构建模块功能，OpenCV可以使用多线程技术。然而，如果你需要写一个简单地图像扫描函数，建议你使用指针方法。迭代器方法是非常安全的，但是非常慢。在调试模式的时候，对整张图片使用运行时修改引用访问方法是最耗时间的。在发布版本里，他可能会打败迭代器方法，因为他确实为了迭代器的安全特性作出了牺牲。

最后，你可以在Youtube上看到本教程的演示视频。
